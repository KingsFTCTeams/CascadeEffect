#pragma config(Sensor, S1,     GyroSensor,     sensorAnalogInactive)
#pragma config(Motor,  motorA,          turnMotor,     tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          driveMotor,    tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          driveMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//int GyroSensor = 0;

#define TEAM_NUMBER 3717

#include "JoystickDriver.c"
#include "Includes/TeamConfig.h"
#include "../Common/GlobalDefines.h"
#include "../Common/Control/SensorTask.h"

float calcJoystickAngle(int xaxis, int yaxis); //function prototypes
int calcJoyPower(int xaxis, int yaxis);
float calcGoalAngle(float joyAngle, float gyroAngle, float wheelAngle);
void turnSwerveSystem(float goalAngle2, float joyPower2);

float joyAngle = 0.0;
int joyPower = 0;
float goalAngle = 0.0;
float lastGoalAngle = 0.0;
int driveDirection = 1;

int testVar = 0;

task main()
{
	StartTask(SensorTask);
  eraseDisplay();
	nMotorEncoder[motorA] = 0;

  int yaxis = 0;
  int xaxis = 0;

  while (true) {
  	disableDiagnosticsDisplay();
  	getJoystickSettings(joystick);
	  yaxis = joystick.joy1_y1;
    xaxis = joystick.joy1_x1;

    joyAngle = calcJoystickAngle(xaxis, yaxis);
    joyPower = calcJoyPower(xaxis, yaxis);
    goalAngle = calcGoalAngle((float)joyAngle, Gyro.fAngle, -(float)nMotorEncoder[motorA]/4.2);
    lastGoalAngle = goalAngle;
    turnSwerveSystem(goalAngle, (float)joyPower);
    nxtDisplayCenteredTextLine(2, "joyAngle: %4.2f", joyAngle);
    nxtDisplayCenteredTextLine(4, "gyroAngle: %4.2f", Gyro.fAngle);
    nxtDisplayCenteredTextLine(6, "goalAngle: %4.2f", goalAngle);
    nxtDisplayCenteredTextLine(7, "testVar: %4d", testVar);

    wait1Msec(10); //buffer for debugger console
	}
}

float calcJoystickAngle(int xaxis, int yaxis) {
  float angle;
	if(abs(yaxis) > 10 || abs(xaxis) > 10) {
	  angle = atan(((float)yaxis/(float)xaxis));
	  angle = angle * (180.0/PI);
		if(yaxis >= 0 && xaxis >= 0) {
		  angle = 90.0 - abs(angle);
		}
		else if(yaxis <= 0 && xaxis >= 0) {
		  angle = abs(angle) + 90.0;
		}
		else if(yaxis <= 0 && xaxis <= 0) {
		  angle = 90.0 - abs(angle) + 180.0;
		}
		else if(yaxis >= 0 && xaxis <= 0) {
		  angle = abs(angle) + 270.0;
		}
		//convert 0<->360 range to -180<->180
		if (angle > 180) {
		  angle = (360.0-angle) * -1.0;
	  }
	  return angle;
  }
  else {
    return 0;
  }
}

float calcGoalAngle(float joyAngle, float gyroAngle, float wheelAngle) {
	float oldAlgorithm = ((gyroAngle + wheelAngle) * -1) + joyAngle; //returns the number of degrees needed acheive desired goal.
  float newAlgorithm = (180 - oldAlgorithm) * -1;
  if (lastGoalAngle < 0.0 && goalAngle > 0.0) {
  	testVar = 1;
  	//return (180 - abs(lastGoalAngle)) + ( 180 - abs(goalAngle));
  }
  else {
	  if (abs(oldAlgorithm) < abs(newAlgorithm)) {
	    driveDirection = 1;
	    return oldAlgorithm;
	  }
	  else {
	    driveDirection = -1;
	    return newAlgorithm;
	  }
	}
}

int calcJoyPower(int xaxis, int yaxis)
{
	float power = sqrt(pow(abs(xaxis),2) + pow(abs(yaxis),2));
	return (int)(power*0.78125); //translate max joystick value of 128 to max motor value of 100
}

void turnSwerveSystem(float goalAngle2, float joyPower2) {
  int goalTick = (int)(goalAngle2 * 4.2); //translate degrees to ticks

  if (abs(goalTick) < 2) { //threshold of 10 ticks - if it's reached the goal
  	motor[motorA] = 0;
	}
	else {
	  if (goalTick < 0) {
	  	motor[motorA] = abs(goalAngle)*5;
	  }
	  else {
	  	motor[motorA] = -abs(goalAngle)*5;
	  }
	}

	//motor[motorB] = joyPower2 * driveDirection;
	//motor[motorC] = joyPower2 * driveDirection;
}
