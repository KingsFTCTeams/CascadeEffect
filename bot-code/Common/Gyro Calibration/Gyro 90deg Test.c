#pragma config(Sensor, S2,              HTSmuxLo,             sensorI2CCustom)
//#pragma config(Sensor, S1,     GYRO,                sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool bDisplayDiagnostics = false;

#define USING_GYRO

#define USING_SMUX

#ifdef USING_SMUX
  #define GYRO    msensor_S2_1
	#define InitSmuxLo() { HTSMUXinit(); HTSMUXscanPorts(HTSmuxLo); }
	#define InitSmuxHi() { }
#else
  #define InitSmuxHi() { }
  #define InitSmuxLo() { }
#endif


#define ReadAccel()   { }
#define ReadUSright() 0
#define ReadUSleft()  0
#define ReadIRleft()  0
#define ReadIRright() 0
#define ReadMAG()     0
#define ReadGYRO()    HTGYROreadRot(GYRO)

#define InitMAG()   { }
#define InitGYRO()  { if (SensorType[GYRO] != sensorRawValue) { SetSensorType(GYRO, sensorRawValue); wait1Msec(100); } }

#define SENSOR_TASK_SAMPLE_RATE 50

#define ENABLE_PID_TURN_CONTROL // this turns on gyro control

#include "GlobalDefines.h"

#include "RobotC Drivers v1.8.1\drivers\common.h"

#include "Control\SensorTask.h"
#include "NXT2excel.h"
#include "NxtButtons.h"

#ifdef USING_SMUX
  tSensorLocation gGyroLoc = ON_SMUX;
#else
  tSensorLocation gGyroLoc = ON_BRICK;
#endif

task main()
{
  WaitForNxtButtonRelease();

  InitGyroInfo(gGyroLoc);

  StartTask(SensorTask);

  while (true)
  {
    eraseDisplay();
    nxtDisplayTextLine(0, "time: %ld", nPgmTime);
    nxtDisplayTextLine(1, "loc:  %d", Gyro.nGyroLoc);
    nxtDisplayTextLine(2, "tDelta: %ld", Gyro.lTimeDelta);
    nxtDisplayTextLine(4, "angle:  %3.2f", Gyro.fAngle);
    nxtDisplayTextLine(7, "bttry:  %d", (int)nAvgBatteryLevel);

    if (GetNxtButton() == kEnterButton && time1[T1] > 250)
    {
      nxtDisplayTextLine(0, "xmting");

	    NXT2excelAddInt(Gyro.nGyroLoc);
	    NXT2excelAddLong(Gyro.lTimeDelta);
	    NXT2excelAddFloat(Gyro.fAngle);
	    NXT2excelAddLong(nAvgBatteryLevel);
	    NXT2excelSendMessage();

	    ResetGyroInfo();

		  WaitForNxtButtonRelease();
	  }

    wait1Msec(50);

  }
}
